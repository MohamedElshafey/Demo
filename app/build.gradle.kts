import groovy.json.JsonSlurper
import java.util.Locale

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.kotlin.kapt)
    alias(libs.plugins.dagger.hilt)
}

android {
    namespace = "egipa.digitalegypt.com.egipa"
    compileSdk = 35

    defaultConfig {
        applicationId = "egipa.digitalegypt.com.egipa"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
    buildFeatures {
        compose = true
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.hilt.android)
    implementation(libs.androidx.appcompat)
    kapt(libs.hilt.android.compiler)
    implementation(libs.androidx.navigation.compose)
    implementation(libs.androidx.material)
    implementation(libs.androidx.hilt.navigation.compose)

    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}

// Allow references to generated code
kapt {
    correctErrorTypes = true
}

// Hook generateStrings to preBuild
tasks.named("preBuild") {
    dependsOn("generateStrings")
    dependsOn("generateCustomColors")
}

/**
 * Task: generateCustomColors
 *
 * This Gradle task generates a `CustomColors` Kotlin class from JSON files containing color definitions
 * for both light and dark themes. It processes all JSON files in the `src/main/assets/colors` directory
 * and generates the class in the `egipa.digitalegypt.com.egipa.ui.theme` package.
 */
tasks.register("generateCustomColors") {
    val inputDir = File(projectDir, "src/main/assets/colors") // Input JSON folder
    val outputDir =
        File(projectDir, "src/main/java/egipa/digitalegypt/com/egipa/ui/theme") // Output Kotlin folder
    val packageName = "egipa.digitalegypt.com.egipa.ui.theme" // Target package name

    doLast {
        // Ensure the output directory exists
        outputDir.mkdirs()

        val colorsMap = mutableMapOf<String, Map<String, String>>()

        // Read all JSON files and parse their content
        inputDir.listFiles()?.filter { it.extension == "json" }?.forEach { file ->
            val jsonContent = JsonSlurper().parse(file) as Map<String, Map<String, String>>
            colorsMap.putAll(jsonContent)
        }

        // Generate the Kotlin file
        val generatedCode = buildString {
            appendLine("package $packageName")
            appendLine()
            appendLine("import androidx.compose.ui.graphics.Color")
            appendLine()
            appendLine("// Auto-generated by Gradle task: Do not edit manually.")
            appendLine()

            // Generate the CustomColors data class
            appendLine("data class CustomColors(")
            colorsMap.keys.forEach { key ->
                appendLine("    val ${key.toCamelCase()}: Color,")
            }
            appendLine(")")
            appendLine()

            // Generate the LightCustomColors object
            appendLine("val LightCustomColors = CustomColors(")
            colorsMap.forEach { (key, value) ->
                appendLine("    ${key.toCamelCase()} = Color(0xFF${value["light"]}),")
            }
            appendLine(")")
            appendLine()

            // Generate the DarkCustomColors object
            appendLine("val DarkCustomColors = CustomColors(")
            colorsMap.forEach { (key, value) ->
                appendLine("    ${key.toCamelCase()} = Color(0xFF${value["dark"]}),")
            }
            appendLine(")")
        }

        // Write the generated code to a file
        val outputFile = File(outputDir, "ThemeColors.kt")
        outputFile.writeText(generatedCode)

        println("ThemeColors.kt generated successfully at $outputDir")
    }
}

// Helper function to convert snake_case to camelCase
fun String.toCamelCase(): String {
    return split("_").joinToString("") {
        it.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
    }.replaceFirstChar { it.lowercase(Locale.getDefault()) }
}


/**
 * Task: generateStrings
 *
 * This Gradle task automates the generation and updating of `strings.xml` files
 * for Android localization. It reads JSON files from the `assets/strings` folder,
 * parses them to extract English and Arabic translations, and generates/upgrades
 * the corresponding `strings.xml` files in the `res/values` and `res/values-ar` folders.
 */
tasks.register("generateStrings") {
    val inputDir = File(projectDir, "src/main/assets/strings")
    val outputDirBase = File(projectDir, "src/main/res")
    val englishDir = File(outputDirBase, "values")
    val arabicDir = File(outputDirBase, "values-ar")

    doLast {
        // Ensure output directories exist
        englishDir.mkdirs()
        arabicDir.mkdirs()

        // Initialize maps for English and Arabic strings
        val englishStrings = mutableMapOf<String, String>()
        val arabicStrings = mutableMapOf<String, String>()

        // Read all JSON files from the input directory
        inputDir.listFiles()?.filter { it.extension == "json" }?.forEach { file ->
            val jsonContent = JsonSlurper().parse(file) as Map<*, *>

            // Parse the JSON and populate the maps
            jsonContent.forEach { (key, value) ->
                if (key is String && value is Map<*, *>) {
                    val en = value["en"] as? String
                    val ar = value["ar"] as? String
                    if (!en.isNullOrEmpty()) englishStrings[key] = en
                    if (!ar.isNullOrEmpty()) arabicStrings[key] = ar
                }
            }
        }

        // Load existing strings
        val existingEnglishStrings = loadExistingStrings(File(englishDir, "strings.xml"))
        val existingArabicStrings = loadExistingStrings(File(arabicDir, "strings.xml"))

        // Merge existing strings and update only keys present in JSON
        val finalEnglishStrings = existingEnglishStrings.toMutableMap().apply {
            putAll(englishStrings) // Overwrites existing keys with JSON values
        }

        val finalArabicStrings = existingArabicStrings.toMutableMap().apply {
            putAll(arabicStrings) // Overwrites existing keys with JSON values
        }

        // Generate strings.xml for English
        generateXmlFile(englishDir.resolve("strings.xml"), finalEnglishStrings)

        // Generate strings.xml for Arabic
        generateXmlFile(arabicDir.resolve("strings.xml"), finalArabicStrings)

        println("Strings.xml files updated successfully!")
    }
}


// Helper function to generate an XML file
fun generateXmlFile(file: File, stringsMap: Map<String, String>) {
    val xmlContent = buildString {
        appendLine("""<?xml version="1.0" encoding="utf-8"?>""")
        appendLine("<resources>")
        stringsMap.forEach { (key, value) ->
            appendLine("    <string name=\"$key\">${escapeXml(value)}</string>")
        }
        appendLine("</resources>")
    }
    file.writeText(xmlContent)
}

// Helper function to escape XML special characters
fun escapeXml(text: String): String {
    return text
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace("\"", "&quot;")
        .replace("'", "\\'")
}

// Helper function to load existing strings from an XML file
fun loadExistingStrings(file: File): Map<String, String> {
    if (!file.exists()) return emptyMap()

    val existingStrings = mutableMapOf<String, String>()
    val regex = Regex("""<string name="(.+?)">(.+?)</string>""")

    file.readLines().forEach { line ->
        regex.find(line)?.let {
            val key = it.groupValues[1]
            val value = it.groupValues[2]
            existingStrings[key] = value
        }
    }
    return existingStrings
}